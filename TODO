‚Ä¢ If you need more C functions, you can use them but always prefer C++.
‚Ä¢ The C++ standard must be C++ 98. Your project must compile with it.
‚Ä¢ No external library, no Boost, etc...
‚Ä¢ Try to always use the most "C++" code possible (for example use <cstring> over <string.h>).
‚Ä¢ Your server must be compatible with the web browser of your choice.
‚Ä¢ You can use every macroanddefinelike FD_SET,FD_CLR,FD_ISSET,FD_ZERO (understanding what they do and how they do it is very useful.)
üëç ‚Ä¢ You must write an HTTP server in C++ 98. OK
üëç ‚Ä¢ In the subject and the scale we will mention poll but you can use equivalent like select, kqueue, epoll.
üëç ‚Ä¢ You should never do a read operation or a write operation without going through poll (or equivalent).
üëç ‚Ä¢ Your server can listen on multiple ports (See config file).
üëç ‚Ä¢ Checking the value of errno is strictly forbidden after a read or a write operation.
üëç ‚Ä¢ You can‚Äôt use fork for something else than CGI (like php or python etc...)
üëç ‚Ä¢ You can‚Äôt execve another webserver...
üëç ‚Ä¢ You don‚Äôt need to use poll (or equivalent) before reading your config file.
‚è≥ ‚Ä¢ It must be non-blocking and use only 1 poll (or equivalent) for all the IO between the client and the server (listens includes).
‚è≥ ‚Ä¢ Your server should never block and the client should be bounce properly if necessary.
‚è≥ ‚Ä¢ A request to your server should never hang forever.
‚è≥ ‚Ä¢ Your program should have a config file in argument or use a default path.
‚è≥ ‚Ä¢ You should be able to serve a fully static website.
‚è≥ ‚Ä¢ You need at least GET, POST, and DELETE methods.
üëÅüêΩüëÅ ‚Ä¢ Your program should not leak and should never crash, (even when out of memory if all the initialization is done)
‚ùå ‚Ä¢ You server should have default error pages if none are provided.
‚ùå ‚Ä¢ We will consider that Nginx is HTTP 1.1 compliant and may be used to compare headers and answer behaviors.
‚ùå ‚Ä¢ poll (or equivalent) should check read and write at the same time.
‚ùå ‚Ä¢ Client should be able to upload files.
‚ùå ‚Ä¢ Your HTTP response status codes must be accurate.
‚ùå ‚Ä¢ Stress tests your server it must stay available at all cost.

üëç ‚ó¶ choose the port and host of each "server"
üëç ¬∑ the cgi should be run in the correct directory for relative path file access
‚è≥ ‚ó¶ setup the server_names or not
‚è≥ ‚ó¶ The first server for a host:port will be the default for this host:port (meaning it will answer to all request that doesn‚Äôt belong to an other server)
‚è≥ ‚ó¶ limit client body size
‚è≥ ¬∑ Samethings for the output of the CGI.if no content_length is returned from the CGI, EOF will mean the end of the returned data.
‚è≥ ¬∑ Your program should call the cgi with the file requested as first argument
‚ó¶ setup routes with one or multiple of the following rules/configuration (routes wont be using regexp):
  üëç ‚àó define a directory or a file from where the file should be search (for example if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet)
  üëç ‚àó turn on or off directory listing
  üëç ‚àó default file to answer if the request is a directory
  ‚è≥ ‚àó define a list of accepted HTTP Methods for the route
  ‚è≥ ‚àó execute CGI based on certain file extension (for example .php)
  ‚ùå ‚àó define an HTTP redirection.
üëÅüêΩüëÅüîç¬∑ Because you won‚Äôt call the CGI directly use the full path as PATH_INFO
‚ùå ¬∑ Just remembers that for chunked request, your server needs to unchun- ked it and the CGI will expect EOF as end of the body.
‚ùå ‚ó¶ setup default error pages
‚ùå ¬∑ your server should work with one CGI (php-cgi, python...)
‚ùå ¬∑ make the route able to accept uploaded files and configure where it should be saved

Own -> Variables de entorno de CGI ‚ùå
