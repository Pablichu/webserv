â€¢ If you need more C functions, you can use them but always prefer C++.
â€¢ The C++ standard must be C++ 98. Your project must compile with it.
â€¢ No external library, no Boost, etc...
â€¢ Try to always use the most "C++" code possible (for example use <cstring> over <string.h>).
â€¢ Your server must be compatible with the web browser of your choice.
â€¢ You can use every macroanddefinelike FD_SET,FD_CLR,FD_ISSET,FD_ZERO (understanding what they do and how they do it is very useful.)
ğŸ‘ â€¢ You must write an HTTP server in C++ 98. OK
ğŸ‘ â€¢ In the subject and the scale we will mention poll but you can use equivalent like select, kqueue, epoll.
ğŸ‘ â€¢ You should never do a read operation or a write operation without going through poll (or equivalent).
ğŸ‘ â€¢ Your server can listen on multiple ports (See config file).
ğŸ‘ â€¢ Checking the value of errno is strictly forbidden after a read or a write operation.
ğŸ‘ â€¢ You canâ€™t use fork for something else than CGI (like php or python etc...)
ğŸ‘ â€¢ You canâ€™t execve another webserver...
ğŸ‘ â€¢ You donâ€™t need to use poll (or equivalent) before reading your config file.
ğŸ‘ â€¢ Your program should have a config file in argument or use a default path.
ğŸ‘ â€¢ You should be able to serve a fully static website.
ğŸ‘ â€¢ You server should have default error pages if none are provided.
ğŸ‘ â€¢ It must be non-blocking and use only 1 poll (or equivalent) for all the IO between the client and the server (listens includes).
ğŸ‘ â€¢ You need at least GET, POST, and DELETE methods.
ğŸ‘ â€¢ Client should be able to upload files.
â³ â€¢ Your server should never block and the client should be bounce properly if necessary.
â³ â€¢ A request to your server should never hang forever.
â³ â€¢ Your HTTP response status codes must be accurate.
â³ â€¢ poll (or equivalent) should check read and write at the same time.
âŒ â€¢ We will consider that Nginx is HTTP 1.1 compliant and may be used to compare headers and answer behaviors.
âŒ â€¢ Stress tests your server it must stay available at all cost.
ğŸ‘ğŸ½ğŸ‘ â€¢ Your program should not leak and should never crash, (even when out of memory if all the initialization is done)

â—¦ setup routes with one or multiple of the following rules/configuration (routes wont be using regexp):
  ğŸ‘ âˆ— define a directory or a file from where the file should be search (for example if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet)
  ğŸ‘ âˆ— turn on or off directory listing
  ğŸ‘ âˆ— default file to answer if the request is a directory
  ğŸ‘ âˆ— define a list of accepted HTTP Methods for the route
  ğŸ‘ â—¦ choose the port and host of each "server"
  ğŸ‘ Â· the cgi should be run in the correct directory for relative path file access
  ğŸ‘ â—¦ The first server for a host:port will be the default for this host:port (meaning it will answer to all request that doesnâ€™t belong to an other server)
  ğŸ‘ â—¦ setup default error pages
  ğŸ‘ âˆ— define an HTTP redirection.
  ğŸ‘ Â· make the route able to accept uploaded files and configure where it should be saved
  ğŸ‘ âˆ— execute CGI based on certain file extension (for example .php)
  ğŸ‘ Â· Samethings for the output of the CGI.if no content_length is returned from the CGI, EOF will mean the end of the returned data.
  ğŸ‘ Â· Your program should call the cgi with the file requested as first argument
  ğŸ‘ Â· Just remembers that for chunked request, your server needs to unchun- ked it and the CGI will expect EOF as end of the body.
  â³ â—¦ setup the server_names or not
  â³ â—¦ limit client body size (needs to be tested)
  â³ Because you wonâ€™t call the CGI directly use the full path as PATH_INFO
  â³ Â· your server should work with one CGI (php-cgi, python...)

	<<<<<< BONUS >>>>>>
		ğŸ‘  Multiple CGI
		â³  Cookies ğŸª 

Movidas del Peblo:
-  template for errors html
-  frontend pagina de fotos
-  cookies
