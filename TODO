â€¢ If you need more C functions, you can use them but always prefer C++.
â€¢ The C++ standard must be C++ 98. Your project must compile with it.
â€¢ No external library, no Boost, etc...
â€¢ Try to always use the most "C++" code possible (for example use <cstring> over <string.h>).
â€¢ Your server must be compatible with the web browser of your choice.
â€¢ You can use every macroanddefinelike FD_SET,FD_CLR,FD_ISSET,FD_ZERO (understanding what they do and how they do it is very useful.)
ğŸ‘ â€¢ You must write an HTTP server in C++ 98. OK
ğŸ‘ â€¢ In the subject and the scale we will mention poll but you can use equivalent like select, kqueue, epoll.
ğŸ‘ â€¢ You should never do a read operation or a write operation without going through poll (or equivalent).
ğŸ‘ â€¢ Your server can listen on multiple ports (See config file).
ğŸ‘ â€¢ Checking the value of errno is strictly forbidden after a read or a write operation.
ğŸ‘ â€¢ You canâ€™t use fork for something else than CGI (like php or python etc...)
ğŸ‘ â€¢ You canâ€™t execve another webserver...
ğŸ‘ â€¢ You donâ€™t need to use poll (or equivalent) before reading your config file.
ğŸ‘ â€¢ Your program should have a config file in argument or use a default path.
ğŸ‘ â€¢ You should be able to serve a fully static website.
ğŸ‘ â€¢ You server should have default error pages if none are provided.
ğŸ‘ â€¢ It must be non-blocking and use only 1 poll (or equivalent) for all the IO between the client and the server (listens includes).
â³ â€¢ Your server should never block and the client should be bounce properly if necessary.
â³ â€¢ A request to your server should never hang forever.
â³ â€¢ You need at least GET, POST, and DELETE methods.
â³ â€¢ Client should be able to upload files.
â³ â€¢ Your HTTP response status codes must be accurate.
â³ â€¢ poll (or equivalent) should check read and write at the same time.
ğŸ‘ğŸ½ğŸ‘ â€¢ Your program should not leak and should never crash, (even when out of memory if all the initialization is done)
âŒ â€¢ We will consider that Nginx is HTTP 1.1 compliant and may be used to compare headers and answer behaviors.
âŒ â€¢ Stress tests your server it must stay available at all cost.

â—¦ setup routes with one or multiple of the following rules/configuration (routes wont be using regexp):
  ğŸ‘ âˆ— define a directory or a file from where the file should be search (for example if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet)
  ğŸ‘ âˆ— turn on or off directory listing
  ğŸ‘ âˆ— default file to answer if the request is a directory
  ğŸ‘ âˆ— define a list of accepted HTTP Methods for the route
  ğŸ‘ â—¦ choose the port and host of each "server"
  ğŸ‘ Â· the cgi should be run in the correct directory for relative path file access
  ğŸ‘ â—¦ The first server for a host:port will be the default for this host:port (meaning it will answer to all request that doesnâ€™t belong to an other server)
  ğŸ‘ â—¦ setup default error pages
  ğŸ‘ âˆ— define an HTTP redirection.
  â³ â—¦ setup the server_names or not
  â³ â—¦ limit client body size
  â³ Â· Samethings for the output of the CGI.if no content_length is returned from the CGI, EOF will mean the end of the returned data.
  â³ Â· Your program should call the cgi with the file requested as first argument
  â³ âˆ— execute CGI based on certain file extension (for example .php)
  ğŸ‘ğŸ½ğŸ‘ğŸ”Â· Because you wonâ€™t call the CGI directly use the full path as PATH_INFO
  âŒ Â· Just remembers that for chunked request, your server needs to unchun- ked it and the CGI will expect EOF as end of the body.
  âŒ Â· your server should work with one CGI (php-cgi, python...)
  âŒ Â· make the route able to accept uploaded files and configure where it should be saved

Movidas del Peblo:
-  chunked
-  template for errors html
